/// <reference types="node" />
import { Connection } from "./connection";
import { ArrayCursor } from "./cursor";
import { CollectionChecksum, CollectionFigures, CollectionProperties, CollectionPropertiesOptions, CreateCollectionOptions, CreateCollectionQueryOptions, Document, DocumentData, Edge, InsertOptions, RemoveByExampleOptions, RemoveOptions, ReplaceOptions, UpdateByExampleOptions, UpdateOptions } from "./util/types";
export declare enum CollectionType {
    DOCUMENT_COLLECTION = 2,
    EDGE_COLLECTION = 3
}
export declare type DocumentHandle = string | {
    _key?: string;
    _id?: string;
};
export declare type IndexHandle = string | {
    id?: string;
};
export interface ImportOptions {
    type?: null | "auto" | "documents" | "array";
    fromPrefix?: string;
    toPrefix?: string;
    overwrite?: boolean;
    waitForSync?: boolean;
    onDuplicate?: "error" | "update" | "replace" | "ignore";
    complete?: boolean;
    details?: boolean;
}
export interface ImportResult {
    error: false;
    created: number;
    errors: number;
    empty: number;
    updated: number;
    ignored: number;
    details?: string[];
}
export interface DocumentReadOptions {
    graceful?: boolean;
    allowDirtyRead?: boolean;
}
export declare function isArangoCollection(collection: any): collection is ArangoCollection;
export interface ArangoCollection {
    isArangoCollection: true;
    name: string;
}
export declare const DOCUMENT_NOT_FOUND = 1202;
export declare const COLLECTION_NOT_FOUND = 1203;
export declare abstract class BaseCollection<T extends object = any> implements ArangoCollection {
    isArangoCollection: true;
    name: string;
    abstract type: CollectionType;
    protected _idPrefix: string;
    protected _connection: Connection;
    constructor(connection: Connection, name: string);
    protected _documentPath(documentHandle: DocumentHandle): string;
    protected _documentHandle(documentHandle: DocumentHandle): string;
    protected _indexHandle(indexHandle: IndexHandle): string;
    protected _get(path: string, qs?: any): Promise<any>;
    protected _put(path: string, body: any): Promise<any>;
    get(): Promise<any>;
    exists(): Promise<boolean>;
    create(properties?: CreateCollectionOptions & CreateCollectionQueryOptions): Promise<any>;
    properties(): Promise<CollectionProperties>;
    count(): Promise<any>;
    figures(): Promise<CollectionFigures>;
    revision(): Promise<any>;
    checksum(opts?: any): Promise<CollectionChecksum>;
    load(count?: boolean): Promise<any>;
    unload(): Promise<any>;
    setProperties(properties: CollectionPropertiesOptions): Promise<any>;
    rename(name: string): Promise<any>;
    rotate(): Promise<any>;
    truncate(): Promise<any>;
    drop(opts?: any): Promise<any>;
    getResponsibleShard(document: Object): Promise<string>;
    documentExists(documentHandle: DocumentHandle): Promise<boolean>;
    document(documentHandle: DocumentHandle, graceful: boolean): Promise<Document<T>>;
    document(documentHandle: DocumentHandle, opts?: DocumentReadOptions): Promise<Document<T>>;
    replace(documentHandle: DocumentHandle, newValue: Object | Array<Object>, opts?: ReplaceOptions): Promise<any>;
    update(documentHandle: DocumentHandle, newValue: Object | Array<Object>, opts?: UpdateOptions): Promise<any>;
    bulkUpdate(newValues: Object | Array<Object>, opts?: any): Promise<any>;
    remove(documentHandle: DocumentHandle, opts?: RemoveOptions): Promise<any>;
    list(type?: string): Promise<any>;
    all(opts?: any): Promise<ArrayCursor>;
    any(): Promise<any>;
    first(opts?: any): Promise<any>;
    last(opts?: any): Promise<any>;
    byExample(example: any, opts?: any): Promise<ArrayCursor>;
    firstExample(example: any): Promise<any>;
    removeByExample(example: any, opts?: RemoveByExampleOptions): Promise<any>;
    replaceByExample(example: any, newValue: any, opts?: {
        waitForSync?: boolean;
        limit?: number;
    }): Promise<any>;
    updateByExample(example: any, newValue: any, opts?: UpdateByExampleOptions): Promise<any>;
    lookupByKeys(keys: string[]): Promise<any>;
    removeByKeys(keys: string[], options: any): Promise<any>;
    import(data: Buffer | Blob | string | any[], { type, ...opts }?: ImportOptions): Promise<ImportResult>;
    indexes(): Promise<any>;
    index(indexHandle: IndexHandle): Promise<any>;
    ensureIndex(details: any): Promise<any>;
    /** @deprecated use ensureIndex instead */
    createIndex(details: any): Promise<any>;
    dropIndex(indexHandle: IndexHandle): Promise<any>;
    createCapConstraint(opts?: any): Promise<any>;
    createHashIndex(fields: string[] | string, opts?: any): Promise<any>;
    createSkipList(fields: string[] | string, opts?: any): Promise<any>;
    createPersistentIndex(fields: string[] | string, opts?: any): Promise<any>;
    createGeoIndex(fields: string[] | string, opts?: any): Promise<any>;
    createFulltextIndex(fields: string[] | string, minLength?: number): Promise<any>;
    fulltext(attribute: any, query: any, opts?: any): Promise<ArrayCursor>;
}
export declare class DocumentCollection<T extends object = any> extends BaseCollection<T> {
    type: CollectionType;
    constructor(connection: Connection, name: string);
    save(data: DocumentData<T> | Array<DocumentData<T>>, opts?: InsertOptions | boolean): Promise<any>;
}
export declare class EdgeCollection<T extends object = any> extends BaseCollection<T> {
    type: CollectionType;
    constructor(connection: Connection, name: string);
    protected _documentPath(documentHandle: DocumentHandle): string;
    edge(documentHandle: DocumentHandle, graceful: boolean): Promise<Edge<T>>;
    edge(documentHandle: DocumentHandle, opts?: DocumentReadOptions): Promise<Edge<T>>;
    save(data: T | Array<T>, opts?: InsertOptions | boolean): Promise<any>;
    save(data: T | Array<T>, fromId: DocumentHandle, toId: DocumentHandle, opts?: InsertOptions | boolean): Promise<any>;
    protected _edges(documentHandle: DocumentHandle, direction?: "in" | "out"): Promise<any>;
    edges(vertex: DocumentHandle): Promise<any>;
    inEdges(vertex: DocumentHandle): Promise<any>;
    outEdges(vertex: DocumentHandle): Promise<any>;
    traversal(startVertex: DocumentHandle, opts?: any): Promise<any>;
}
export declare function constructCollection(connection: Connection, data: any): DocumentCollection<any>;
//# sourceMappingURL=collection.d.ts.map