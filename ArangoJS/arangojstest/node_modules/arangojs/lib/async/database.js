"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const analyzer_1 = require("./analyzer");
const aql_query_1 = require("./aql-query");
const collection_1 = require("./collection");
const connection_1 = require("./connection");
const cursor_1 = require("./cursor");
const error_1 = require("./error");
const graph_1 = require("./graph");
const route_1 = require("./route");
const transaction_1 = require("./transaction");
const btoa_1 = require("./util/btoa");
const multipart_1 = require("./util/multipart");
const view_1 = require("./view");
function colToString(collection) {
    if (collection_1.isArangoCollection(collection)) {
        return String(collection.name);
    }
    else
        return String(collection);
}
const DATABASE_NOT_FOUND = 1228;
class Database {
    constructor(config) {
        this._connection = new connection_1.Connection(config);
    }
    get name() {
        return this._connection.getDatabaseName() || null;
    }
    //#region misc
    version() {
        return this._connection.request({
            method: "GET",
            path: "/_api/version"
        }, res => res.body);
    }
    route(path, headers) {
        return new route_1.Route(this._connection, path, headers);
    }
    async acquireHostList() {
        if (!this._connection.getDatabaseName()) {
            throw new Error("Cannot acquire host list with absolute URL");
        }
        const urls = await this._connection.request({ path: "/_api/cluster/endpoints" }, res => res.body.endpoints.map((endpoint) => endpoint.endpoint));
        this._connection.addToHostList(urls);
    }
    close() {
        this._connection.close();
    }
    //#endregion
    //#region auth
    login(username = "root", password = "") {
        return this._connection.request({
            method: "POST",
            path: "/_open/auth",
            body: { username, password }
        }, res => {
            this.useBearerAuth(res.body.jwt);
            return res.body.jwt;
        });
    }
    useBearerAuth(token) {
        this._connection.setHeader("authorization", `Bearer ${token}`);
        return this;
    }
    useBasicAuth(username = "root", password = "") {
        this._connection.setHeader("authorization", `Basic ${btoa_1.btoa(`${username}:${password}`)}`);
        return this;
    }
    //#endregion
    //#region databases
    useDatabase(databaseName) {
        this._connection.setDatabaseName(databaseName);
        return this;
    }
    get() {
        return this._connection.request({ path: "/_api/database/current" }, res => res.body.result);
    }
    exists() {
        return this.get().then(() => true, err => {
            if (error_1.isArangoError(err) && err.errorNum === DATABASE_NOT_FOUND) {
                return false;
            }
            throw err;
        });
    }
    createDatabase(databaseName, users) {
        return this._connection.request({
            method: "POST",
            path: "/_api/database",
            body: { users, name: databaseName }
        }, res => res.body);
    }
    listDatabases() {
        return this._connection.request({ path: "/_api/database" }, res => res.body.result);
    }
    listUserDatabases() {
        return this._connection.request({ path: "/_api/database/user" }, res => res.body.result);
    }
    dropDatabase(databaseName) {
        return this._connection.request({
            method: "DELETE",
            path: `/_api/database/${databaseName}`
        }, res => res.body);
    }
    //#endregion
    //#region collections
    collection(collectionName) {
        return new collection_1.DocumentCollection(this._connection, collectionName);
    }
    edgeCollection(collectionName) {
        return new collection_1.EdgeCollection(this._connection, collectionName);
    }
    listCollections(excludeSystem = true) {
        return this._connection.request({
            path: "/_api/collection",
            qs: { excludeSystem }
        }, res => this._connection.arangoMajor <= 2
            ? res.body.collections
            : res.body.result);
    }
    async collections(excludeSystem = true) {
        const collections = await this.listCollections(excludeSystem);
        return collections.map((data) => collection_1.constructCollection(this._connection, data));
    }
    async truncate(excludeSystem = true) {
        const collections = await this.listCollections(excludeSystem);
        return await Promise.all(collections.map((data) => this._connection.request({
            method: "PUT",
            path: `/_api/collection/${data.name}/truncate`
        }, res => res.body)));
    }
    //#endregion
    //#region views
    arangoSearchView(viewName) {
        return new view_1.ArangoSearchView(this._connection, viewName);
    }
    listViews() {
        return this._connection.request({ path: "/_api/view" }, res => res.body.result);
    }
    async views() {
        const views = await this.listViews();
        return views.map((data) => view_1.constructView(this._connection, data));
    }
    //#endregion
    //#region analyzers
    analyzer(name) {
        return new analyzer_1.ArangoAnalyzer(this._connection, name);
    }
    listAnalyzers() {
        return this._connection.request({ path: "/_api/analyzer" }, res => res.body.result);
    }
    async analyzers() {
        const analyzers = await this.listAnalyzers();
        return analyzers.map(data => this.analyzer(data.name));
    }
    //#endregion
    //#region transactions
    executeTransaction(collections, action, options) {
        return this._connection.request({
            method: "POST",
            path: "/_api/transaction",
            body: {
                collections: coerceTransactionCollections(collections),
                action,
                ...options
            }
        }, res => res.body.result);
    }
    transaction(collectionsOrId, action, params, options) {
        if (arguments.length === 1 && typeof collectionsOrId === "string") {
            return new transaction_1.ArangoTransaction(this._connection, collectionsOrId);
        }
        if (typeof params === "number") {
            options = params;
            params = undefined;
        }
        if (typeof options === "number") {
            options = { lockTimeout: options };
        }
        return this.executeTransaction(collectionsOrId, action, {
            params,
            ...options
        });
    }
    beginTransaction(collections, options) {
        return this._connection.request({
            method: "POST",
            path: "/_api/transaction/begin",
            body: {
                collections: coerceTransactionCollections(collections),
                ...options
            }
        }, res => new transaction_1.ArangoTransaction(this._connection, res.body.result.id));
    }
    listTransactions() {
        return this._connection.request({ path: "/_api/transaction" }, res => res.body.transactions);
    }
    async transactions() {
        const transactions = await this.listTransactions();
        return transactions.map(data => this.transaction(data.id));
    }
    //#endregion
    //#region graphs
    graph(graphName) {
        return new graph_1.Graph(this._connection, graphName);
    }
    listGraphs() {
        return this._connection.request({ path: "/_api/gharial" }, res => res.body.graphs);
    }
    async graphs() {
        const graphs = await this.listGraphs();
        return graphs.map((data) => this.graph(data._key));
    }
    query(query, bindVars, opts) {
        if (aql_query_1.isAqlQuery(query)) {
            opts = bindVars;
            bindVars = query.bindVars;
            query = query.query;
        }
        else if (aql_query_1.isAqlLiteral(query)) {
            query = query.toAQL();
        }
        const { allowDirtyRead = undefined, timeout = undefined, ...extra } = opts || {};
        return this._connection.request({
            method: "POST",
            path: "/_api/cursor",
            body: { ...extra, query, bindVars },
            allowDirtyRead,
            timeout
        }, res => new cursor_1.ArrayCursor(this._connection, res.body, res.arangojsHostId, allowDirtyRead));
    }
    explain(query, bindVars, opts) {
        if (aql_query_1.isAqlQuery(query)) {
            opts = bindVars;
            bindVars = query.bindVars;
            query = query.query;
        }
        else if (aql_query_1.isAqlLiteral(query)) {
            query = query.toAQL();
        }
        return this._connection.request({
            method: "POST",
            path: "/_api/explain",
            body: { options: opts, query, bindVars }
        }, res => res.body);
    }
    parse(query) {
        if (aql_query_1.isAqlQuery(query)) {
            query = query.query;
        }
        else if (aql_query_1.isAqlLiteral(query)) {
            query = query.toAQL();
        }
        return this._connection.request({
            method: "POST",
            path: "/_api/query",
            body: { query }
        }, res => res.body);
    }
    queryTracking() {
        return this._connection.request({
            method: "GET",
            path: "/_api/query/properties"
        }, res => res.body);
    }
    setQueryTracking(opts) {
        return this._connection.request({
            method: "PUT",
            path: "/_api/query/properties",
            body: opts
        }, res => res.body);
    }
    listRunningQueries() {
        return this._connection.request({
            method: "GET",
            path: "/_api/query/current"
        }, res => res.body);
    }
    listSlowQueries() {
        return this._connection.request({
            method: "GET",
            path: "/_api/query/slow"
        }, res => res.body);
    }
    clearSlowQueries() {
        return this._connection.request({
            method: "DELETE",
            path: "/_api/query/slow"
        }, () => undefined);
    }
    killQuery(queryId) {
        return this._connection.request({
            method: "DELETE",
            path: `/_api/query/${queryId}`
        }, () => undefined);
    }
    //#endregion
    //#region functions
    listFunctions() {
        return this._connection.request({ path: "/_api/aqlfunction" }, res => res.body);
    }
    createFunction(name, code) {
        return this._connection.request({
            method: "POST",
            path: "/_api/aqlfunction",
            body: { name, code }
        }, res => res.body);
    }
    dropFunction(name, group = false) {
        return this._connection.request({
            method: "DELETE",
            path: `/_api/aqlfunction/${name}`,
            body: { group }
        }, res => res.body);
    }
    //#endregion
    //#region services
    listServices() {
        return this._connection.request({ path: "/_api/foxx" }, res => res.body);
    }
    async installService(mount, source, opts = {}) {
        const { configuration, dependencies, ...qs } = opts;
        const req = await multipart_1.toForm({
            configuration,
            dependencies,
            source
        });
        return await this._connection.request({
            ...req,
            method: "POST",
            path: "/_api/foxx",
            isBinary: true,
            qs: { ...qs, mount }
        }, res => res.body);
    }
    async upgradeService(mount, source, opts = {}) {
        const { configuration, dependencies, ...qs } = opts;
        const req = await multipart_1.toForm({
            configuration,
            dependencies,
            source
        });
        return await this._connection.request({
            ...req,
            method: "PATCH",
            path: "/_api/foxx/service",
            isBinary: true,
            qs: { ...qs, mount }
        }, res => res.body);
    }
    async replaceService(mount, source, opts = {}) {
        const { configuration, dependencies, ...qs } = opts;
        const req = await multipart_1.toForm({
            configuration,
            dependencies,
            source
        });
        return await this._connection.request({
            ...req,
            method: "PUT",
            path: "/_api/foxx/service",
            isBinary: true,
            qs: { ...qs, mount }
        }, res => res.body);
    }
    uninstallService(mount, opts = {}) {
        return this._connection.request({
            method: "DELETE",
            path: "/_api/foxx/service",
            qs: { ...opts, mount }
        }, () => undefined);
    }
    getService(mount) {
        return this._connection.request({
            path: "/_api/foxx/service",
            qs: { mount }
        }, res => res.body);
    }
    async getServiceConfiguration(mount, minimal = false) {
        const result = await this._connection.request({
            path: "/_api/foxx/configuration",
            qs: { mount, minimal }
        }, res => res.body);
        if (!minimal ||
            !Object.keys(result).every((key) => result[key].title))
            return result;
        const values = {};
        for (const key of Object.keys(result)) {
            values[key] = result[key].current;
        }
        return values;
    }
    async updateServiceConfiguration(mount, cfg, minimal = false) {
        const result = await this._connection.request({
            method: "PATCH",
            path: "/_api/foxx/configuration",
            body: cfg,
            qs: { mount, minimal }
        }, res => res.body);
        if (minimal ||
            !result.values ||
            !Object.keys(result.values).every((key) => result.values[key].title)) {
            return result;
        }
        const result2 = await this.getServiceConfiguration(mount, minimal);
        if (result.warnings) {
            for (const key of Object.keys(result2)) {
                result2[key].warning = result.warnings[key];
            }
        }
        return result2;
    }
    async replaceServiceConfiguration(mount, cfg, minimal = false) {
        const result = await this._connection.request({
            method: "PUT",
            path: "/_api/foxx/configuration",
            body: cfg,
            qs: { mount, minimal }
        }, res => res.body);
        if (minimal ||
            !result.values ||
            !Object.keys(result.values).every((key) => result.values[key].title)) {
            return result;
        }
        const result2 = await this.getServiceConfiguration(mount, minimal);
        if (result.warnings) {
            for (const key of Object.keys(result2)) {
                result2[key].warning = result.warnings[key];
            }
        }
        return result2;
    }
    async getServiceDependencies(mount, minimal = false) {
        const result = await this._connection.request({
            path: "/_api/foxx/dependencies",
            qs: { mount, minimal }
        }, res => res.body);
        if (!minimal ||
            !Object.keys(result).every((key) => result[key].title))
            return result;
        const values = {};
        for (const key of Object.keys(result)) {
            values[key] = result[key].current;
        }
        return values;
    }
    async updateServiceDependencies(mount, cfg, minimal = false) {
        const result = await this._connection.request({
            method: "PATCH",
            path: "/_api/foxx/dependencies",
            body: cfg,
            qs: { mount, minimal }
        }, res => res.body);
        if (minimal ||
            !result.values ||
            !Object.keys(result.values).every((key) => result.values[key].title)) {
            return result;
        }
        const result2 = await this.getServiceDependencies(mount, minimal);
        if (result.warnings) {
            for (const key of Object.keys(result2)) {
                result2[key].warning = result.warnings[key];
            }
        }
        return result2;
    }
    async replaceServiceDependencies(mount, cfg, minimal = false) {
        const result = await this._connection.request({
            method: "PUT",
            path: "/_api/foxx/dependencies",
            body: cfg,
            qs: { mount, minimal }
        }, res => res.body);
        if (minimal ||
            !result.values ||
            !Object.keys(result.values).every((key) => result.values[key].title)) {
            return result;
        }
        const result2 = await this.getServiceDependencies(mount, minimal);
        if (result.warnings) {
            for (const key of Object.keys(result2)) {
                result2[key].warning = result.warnings[key];
            }
        }
        return result2;
    }
    enableServiceDevelopmentMode(mount) {
        return this._connection.request({
            method: "POST",
            path: "/_api/foxx/development",
            qs: { mount }
        }, res => res.body);
    }
    disableServiceDevelopmentMode(mount) {
        return this._connection.request({
            method: "DELETE",
            path: "/_api/foxx/development",
            qs: { mount }
        }, res => res.body);
    }
    listServiceScripts(mount) {
        return this._connection.request({
            path: "/_api/foxx/scripts",
            qs: { mount }
        }, res => res.body);
    }
    runServiceScript(mount, name, args) {
        return this._connection.request({
            method: "POST",
            path: `/_api/foxx/scripts/${name}`,
            body: args,
            qs: { mount }
        }, res => res.body);
    }
    runServiceTests(mount, opts) {
        return this._connection.request({
            method: "POST",
            path: "/_api/foxx/tests",
            qs: {
                ...opts,
                mount
            }
        }, res => res.body);
    }
    getServiceReadme(mount) {
        return this._connection.request({
            path: "/_api/foxx/readme",
            qs: { mount }
        }, res => res.body);
    }
    getServiceDocumentation(mount) {
        return this._connection.request({
            path: "/_api/foxx/swagger",
            qs: { mount }
        }, res => res.body);
    }
    downloadService(mount) {
        return this._connection.request({
            method: "POST",
            path: "/_api/foxx/download",
            qs: { mount },
            expectBinary: true
        }, res => res.body);
    }
    commitLocalServiceState(replace = false) {
        return this._connection.request({
            method: "POST",
            path: "/_api/foxx/commit",
            qs: { replace }
        }, () => undefined);
    }
}
exports.Database = Database;
function coerceTransactionCollections(collections) {
    if (typeof collections === "string") {
        return { write: [collections] };
    }
    if (Array.isArray(collections)) {
        return { write: collections.map(colToString) };
    }
    if (collection_1.isArangoCollection(collections)) {
        return { write: colToString(collections) };
    }
    const cols = {};
    if (collections) {
        if (collections.read) {
            cols.read = Array.isArray(collections.read)
                ? collections.read.map(colToString)
                : colToString(collections.read);
        }
        if (collections.write) {
            cols.write = Array.isArray(collections.write)
                ? collections.write.map(colToString)
                : colToString(collections.write);
        }
        if (collections.exclusive) {
            cols.exclusive = Array.isArray(collections.exclusive)
                ? collections.exclusive.map(colToString)
                : colToString(collections.exclusive);
        }
    }
    return cols;
}
//# sourceMappingURL=database.js.map