{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../src/util/types.ts"],"names":[],"mappings":"","sourcesContent":["export type Errback<T> = (err: Error | null, result?: T) => void;\n\n// The following types are based on the official @arangodb types\n\nexport type KeyGeneratorType = \"traditional\" | \"autoincrement\" | \"uuid\" | \"padded\";\n\nexport interface CollectionChecksum {\n  checksum: string;\n  revision: string;\n}\n\nexport interface CollectionFigures {\n  alive: {\n    count: number;\n    size: number;\n  };\n  dead: {\n    count: number;\n    size: number;\n    deletion: number;\n  };\n  datafiles: {\n    count: number;\n    fileSize: number;\n  };\n  journals: {\n    count: number;\n    fileSize: number;\n  };\n  compactors: {\n    count: number;\n    fileSize: number;\n  };\n  shapefiles: {\n    count: number;\n    fileSize: number;\n  };\n  shapes: {\n    count: number;\n    size: number;\n  };\n  attributes: {\n    count: number;\n    size: number;\n  };\n  indexes: {\n    count: number;\n    size: number;\n  };\n  lastTick: number;\n  uncollectedLogfileEntries: number;\n  documentReferences: number;\n  waitingFor: string;\n  compactionStatus: {\n    time: string;\n    message: string;\n    count: number;\n    filesCombined: number;\n    bytesRead: number;\n    bytesWritten: number;\n  };\n}\n\nexport interface CollectionPropertiesOptions {\n  waitForSync?: boolean;\n  journalSize?: number;\n  indexBuckets?: number;\n  replicationFactor?: number;\n  minReplicationFactor?: number;\n}\n\nexport interface CreateCollectionQueryOptions {\n  waitForSyncReplication?: boolean;\n  enforceReplicationFactor?: boolean;\n}\n\nexport interface CreateCollectionOptions {\n  waitForSync?: boolean;\n  journalSize?: number;\n  isVolatile?: boolean;\n  isSystem?: boolean;\n  keyOptions?: {\n    type?: KeyGeneratorType;\n    allowUserKeys?: boolean;\n    increment?: number;\n    offset?: number;\n  };\n  numberOfShards?: number;\n  shardKeys?: string[];\n  distributeShardsLike?: string;\n  shardingStrategy?: string;\n  smartJoinAttribute?: string;\n  replicationFactor?: number;\n  minReplicationFactor?: number;\n}\n\nexport interface CollectionProperties {\n  waitForSync: boolean;\n  journalSize: number;\n  isSystem: boolean;\n  isVolatile: boolean;\n  keyOptions?: {\n    type: KeyGeneratorType;\n    allowUserKeys: boolean;\n    increment?: number;\n    offset?: number;\n  };\n  indexBuckets: number;\n  numberOfShards?: number;\n  shardKeys?: string[];\n  distributeShardsLike?: string;\n  shardingStrategy?: string;\n  smartJoinAttribute?: string;\n  replicationFactor?: number;\n  minReplicationFactor?: number;\n}\n\n// Document\n\nexport type Patch<T> = { [K in keyof T]?: T[K] | Patch<T[K]> };\n\nexport interface DocumentMetadata {\n  _key: string;\n  _id: string;\n  _rev: string;\n}\n\nexport interface UpdateMetadata extends DocumentMetadata {\n  _oldRev: string;\n}\n\nexport type Document<T extends object = any> = { [K in keyof T]: T[K] } &\n  DocumentMetadata & { _from?: string; _to?: string } & {\n    [key: string]: any;\n  };\nexport type DocumentData<T extends object = any> = { [K in keyof T]: T[K] } &\n  Partial<DocumentMetadata>;\nexport type Edge<T extends object = any> = Document<T> & {\n  _from: string;\n  _to: string;\n};\n\nexport interface InsertOptions {\n  waitForSync?: boolean;\n  silent?: boolean;\n  returnNew?: boolean;\n  overwrite?: boolean;\n}\n\nexport interface ReplaceOptions extends InsertOptions {\n  rev?: string;\n  returnOld?: boolean;\n}\n\nexport interface UpdateOptions extends ReplaceOptions {\n  keepNull?: boolean;\n  mergeObjects?: boolean;\n}\n\nexport interface UpdateByExampleOptions {\n  keepNull?: boolean;\n  waitForSync?: boolean;\n  limit?: number;\n  mergeObjects?: boolean;\n}\n\nexport interface RemoveOptions {\n  rev?: string;\n  waitForSync?: boolean;\n  overwrite?: boolean;\n  returnOld?: boolean;\n  silent?: boolean;\n}\n\nexport interface RemoveByExampleOptions {\n  waitForSync?: boolean;\n  limit?: number;\n}\n"]}